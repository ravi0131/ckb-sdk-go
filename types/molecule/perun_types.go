// Generated by Molecule 0.7.5
// Generated by Moleculec-Go 0.1.11

package molecule

import (
	"bytes"
	"errors"
	"strconv"
	"strings"
)

type SEC1EncodedPubKeyBuilder struct {
	inner [33]Byte
}

func NewSEC1EncodedPubKeyBuilder() *SEC1EncodedPubKeyBuilder {
	return &SEC1EncodedPubKeyBuilder{inner: [33]Byte{ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault(), ByteDefault()}}
}

func (s *SEC1EncodedPubKeyBuilder) Build() SEC1EncodedPubKey {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return SEC1EncodedPubKey{inner: b.Bytes()}
}

func (s *SEC1EncodedPubKeyBuilder) Set(v [33]Byte) *SEC1EncodedPubKeyBuilder {
	s.inner = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth0(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[0] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth1(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[1] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth2(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[2] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth3(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[3] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth4(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[4] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth5(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[5] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth6(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[6] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth7(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[7] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth8(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[8] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth9(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[9] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth10(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[10] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth11(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[11] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth12(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[12] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth13(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[13] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth14(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[14] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth15(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[15] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth16(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[16] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth17(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[17] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth18(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[18] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth19(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[19] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth20(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[20] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth21(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[21] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth22(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[22] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth23(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[23] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth24(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[24] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth25(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[25] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth26(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[26] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth27(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[27] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth28(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[28] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth29(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[29] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth30(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[30] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth31(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[31] = v
	return s
}

func (s *SEC1EncodedPubKeyBuilder) Nth32(v Byte) *SEC1EncodedPubKeyBuilder {
	s.inner[32] = v
	return s
}

type SEC1EncodedPubKey struct {
	inner []byte
}

func SEC1EncodedPubKeyFromSliceUnchecked(slice []byte) *SEC1EncodedPubKey {
	return &SEC1EncodedPubKey{inner: slice}
}
func (s *SEC1EncodedPubKey) AsSlice() []byte {
	return s.inner
}

func SEC1EncodedPubKeyDefault() SEC1EncodedPubKey {
	return *SEC1EncodedPubKeyFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func SEC1EncodedPubKeyFromSlice(slice []byte, _compatible bool) (*SEC1EncodedPubKey, error) {
	sliceLen := len(slice)
	if sliceLen != 33 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SEC1EncodedPubKey", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(33)}, " ")
		return nil, errors.New(errMsg)
	}
	return &SEC1EncodedPubKey{inner: slice}, nil
}

func (s *SEC1EncodedPubKey) RawData() []byte {
	return s.inner
}

func (s *SEC1EncodedPubKey) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *SEC1EncodedPubKey) Nth1() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[1:2])
	return ret
}

func (s *SEC1EncodedPubKey) Nth2() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[2:3])
	return ret
}

func (s *SEC1EncodedPubKey) Nth3() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[3:4])
	return ret
}

func (s *SEC1EncodedPubKey) Nth4() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[4:5])
	return ret
}

func (s *SEC1EncodedPubKey) Nth5() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[5:6])
	return ret
}

func (s *SEC1EncodedPubKey) Nth6() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[6:7])
	return ret
}

func (s *SEC1EncodedPubKey) Nth7() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[7:8])
	return ret
}

func (s *SEC1EncodedPubKey) Nth8() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[8:9])
	return ret
}

func (s *SEC1EncodedPubKey) Nth9() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[9:10])
	return ret
}

func (s *SEC1EncodedPubKey) Nth10() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[10:11])
	return ret
}

func (s *SEC1EncodedPubKey) Nth11() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[11:12])
	return ret
}

func (s *SEC1EncodedPubKey) Nth12() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[12:13])
	return ret
}

func (s *SEC1EncodedPubKey) Nth13() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[13:14])
	return ret
}

func (s *SEC1EncodedPubKey) Nth14() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[14:15])
	return ret
}

func (s *SEC1EncodedPubKey) Nth15() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[15:16])
	return ret
}

func (s *SEC1EncodedPubKey) Nth16() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[16:17])
	return ret
}

func (s *SEC1EncodedPubKey) Nth17() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[17:18])
	return ret
}

func (s *SEC1EncodedPubKey) Nth18() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[18:19])
	return ret
}

func (s *SEC1EncodedPubKey) Nth19() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[19:20])
	return ret
}

func (s *SEC1EncodedPubKey) Nth20() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[20:21])
	return ret
}

func (s *SEC1EncodedPubKey) Nth21() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[21:22])
	return ret
}

func (s *SEC1EncodedPubKey) Nth22() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[22:23])
	return ret
}

func (s *SEC1EncodedPubKey) Nth23() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[23:24])
	return ret
}

func (s *SEC1EncodedPubKey) Nth24() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[24:25])
	return ret
}

func (s *SEC1EncodedPubKey) Nth25() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[25:26])
	return ret
}

func (s *SEC1EncodedPubKey) Nth26() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[26:27])
	return ret
}

func (s *SEC1EncodedPubKey) Nth27() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[27:28])
	return ret
}

func (s *SEC1EncodedPubKey) Nth28() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[28:29])
	return ret
}

func (s *SEC1EncodedPubKey) Nth29() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[29:30])
	return ret
}

func (s *SEC1EncodedPubKey) Nth30() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[30:31])
	return ret
}

func (s *SEC1EncodedPubKey) Nth31() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[31:32])
	return ret
}

func (s *SEC1EncodedPubKey) Nth32() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[32:33])
	return ret
}

func (s *SEC1EncodedPubKey) AsBuilder() SEC1EncodedPubKeyBuilder {
	t := NewSEC1EncodedPubKeyBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	t.Nth2(*s.Nth2())
	t.Nth3(*s.Nth3())
	t.Nth4(*s.Nth4())
	t.Nth5(*s.Nth5())
	t.Nth6(*s.Nth6())
	t.Nth7(*s.Nth7())
	t.Nth8(*s.Nth8())
	t.Nth9(*s.Nth9())
	t.Nth10(*s.Nth10())
	t.Nth11(*s.Nth11())
	t.Nth12(*s.Nth12())
	t.Nth13(*s.Nth13())
	t.Nth14(*s.Nth14())
	t.Nth15(*s.Nth15())
	t.Nth16(*s.Nth16())
	t.Nth17(*s.Nth17())
	t.Nth18(*s.Nth18())
	t.Nth19(*s.Nth19())
	t.Nth20(*s.Nth20())
	t.Nth21(*s.Nth21())
	t.Nth22(*s.Nth22())
	t.Nth23(*s.Nth23())
	t.Nth24(*s.Nth24())
	t.Nth25(*s.Nth25())
	t.Nth26(*s.Nth26())
	t.Nth27(*s.Nth27())
	t.Nth28(*s.Nth28())
	t.Nth29(*s.Nth29())
	t.Nth30(*s.Nth30())
	t.Nth31(*s.Nth31())
	t.Nth32(*s.Nth32())
	return *t
}

type CKByteDistributionBuilder struct {
	inner [2]Uint64
}

func NewCKByteDistributionBuilder() *CKByteDistributionBuilder {
	return &CKByteDistributionBuilder{inner: [2]Uint64{Uint64Default(), Uint64Default()}}
}

func (s *CKByteDistributionBuilder) Build() CKByteDistribution {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return CKByteDistribution{inner: b.Bytes()}
}

func (s *CKByteDistributionBuilder) Set(v [2]Uint64) *CKByteDistributionBuilder {
	s.inner = v
	return s
}

func (s *CKByteDistributionBuilder) Nth0(v Uint64) *CKByteDistributionBuilder {
	s.inner[0] = v
	return s
}

func (s *CKByteDistributionBuilder) Nth1(v Uint64) *CKByteDistributionBuilder {
	s.inner[1] = v
	return s
}

type CKByteDistribution struct {
	inner []byte
}

func CKByteDistributionFromSliceUnchecked(slice []byte) *CKByteDistribution {
	return &CKByteDistribution{inner: slice}
}
func (s *CKByteDistribution) AsSlice() []byte {
	return s.inner
}

func CKByteDistributionDefault() CKByteDistribution {
	return *CKByteDistributionFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CKByteDistributionFromSlice(slice []byte, _compatible bool) (*CKByteDistribution, error) {
	sliceLen := len(slice)
	if sliceLen != 16 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "CKByteDistribution", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(16)}, " ")
		return nil, errors.New(errMsg)
	}
	return &CKByteDistribution{inner: slice}, nil
}

func (s *CKByteDistribution) Nth0() *Uint64 {
	ret := Uint64FromSliceUnchecked(s.inner[0:8])
	return ret
}

func (s *CKByteDistribution) Nth1() *Uint64 {
	ret := Uint64FromSliceUnchecked(s.inner[8:16])
	return ret
}

func (s *CKByteDistribution) AsBuilder() CKByteDistributionBuilder {
	t := NewCKByteDistributionBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	return *t
}

type SUDTDistributionBuilder struct {
	inner [2]Uint128
}

func NewSUDTDistributionBuilder() *SUDTDistributionBuilder {
	return &SUDTDistributionBuilder{inner: [2]Uint128{Uint128Default(), Uint128Default()}}
}

func (s *SUDTDistributionBuilder) Build() SUDTDistribution {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return SUDTDistribution{inner: b.Bytes()}
}

func (s *SUDTDistributionBuilder) Set(v [2]Uint128) *SUDTDistributionBuilder {
	s.inner = v
	return s
}

func (s *SUDTDistributionBuilder) Nth0(v Uint128) *SUDTDistributionBuilder {
	s.inner[0] = v
	return s
}

func (s *SUDTDistributionBuilder) Nth1(v Uint128) *SUDTDistributionBuilder {
	s.inner[1] = v
	return s
}

type SUDTDistribution struct {
	inner []byte
}

func SUDTDistributionFromSliceUnchecked(slice []byte) *SUDTDistribution {
	return &SUDTDistribution{inner: slice}
}
func (s *SUDTDistribution) AsSlice() []byte {
	return s.inner
}

func SUDTDistributionDefault() SUDTDistribution {
	return *SUDTDistributionFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func SUDTDistributionFromSlice(slice []byte, _compatible bool) (*SUDTDistribution, error) {
	sliceLen := len(slice)
	if sliceLen != 32 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SUDTDistribution", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(32)}, " ")
		return nil, errors.New(errMsg)
	}
	return &SUDTDistribution{inner: slice}, nil
}

func (s *SUDTDistribution) Nth0() *Uint128 {
	ret := Uint128FromSliceUnchecked(s.inner[0:16])
	return ret
}

func (s *SUDTDistribution) Nth1() *Uint128 {
	ret := Uint128FromSliceUnchecked(s.inner[16:32])
	return ret
}

func (s *SUDTDistribution) AsBuilder() SUDTDistributionBuilder {
	t := NewSUDTDistributionBuilder()
	t.Nth0(*s.Nth0())
	t.Nth1(*s.Nth1())
	return *t
}

type SUDTAllocationBuilder struct {
	inner []SUDTBalances
}

func (s *SUDTAllocationBuilder) Build() SUDTAllocation {
	itemCount := len(s.inner)

	b := new(bytes.Buffer)

	// Empty dyn vector, just return size's bytes
	if itemCount == 0 {
		b.Write(packNumber(Number(HeaderSizeUint)))
		return SUDTAllocation{inner: b.Bytes()}
	}

	// Calculate first offset then loop for rest items offsets
	totalSize := HeaderSizeUint * uint32(itemCount+1)
	offsets := make([]uint32, 0, itemCount)
	offsets = append(offsets, totalSize)
	for i := 1; i < itemCount; i++ {
		totalSize += uint32(len(s.inner[i-1].AsSlice()))
		offsets = append(offsets, offsets[i-1]+uint32(len(s.inner[i-1].AsSlice())))
	}
	totalSize += uint32(len(s.inner[itemCount-1].AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < itemCount; i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	for i := 0; i < itemCount; i++ {
		b.Write(s.inner[i].AsSlice())
	}

	return SUDTAllocation{inner: b.Bytes()}
}

func (s *SUDTAllocationBuilder) Set(v []SUDTBalances) *SUDTAllocationBuilder {
	s.inner = v
	return s
}
func (s *SUDTAllocationBuilder) Push(v SUDTBalances) *SUDTAllocationBuilder {
	s.inner = append(s.inner, v)
	return s
}
func (s *SUDTAllocationBuilder) Extend(iter []SUDTBalances) *SUDTAllocationBuilder {
	for i := 0; i < len(iter); i++ {
		s.inner = append(s.inner, iter[i])
	}
	return s
}
func (s *SUDTAllocationBuilder) Replace(index uint, v SUDTBalances) *SUDTBalances {
	if uint(len(s.inner)) > index {
		a := s.inner[index]
		s.inner[index] = v
		return &a
	}
	return nil
}

func NewSUDTAllocationBuilder() *SUDTAllocationBuilder {
	return &SUDTAllocationBuilder{[]SUDTBalances{}}
}

type SUDTAllocation struct {
	inner []byte
}

func SUDTAllocationFromSliceUnchecked(slice []byte) *SUDTAllocation {
	return &SUDTAllocation{inner: slice}
}
func (s *SUDTAllocation) AsSlice() []byte {
	return s.inner
}

func SUDTAllocationDefault() SUDTAllocation {
	return *SUDTAllocationFromSliceUnchecked([]byte{4, 0, 0, 0})
}

func SUDTAllocationFromSlice(slice []byte, compatible bool) (*SUDTAllocation, error) {
	sliceLen := len(slice)

	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SUDTAllocation", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SUDTAllocation", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) == HeaderSizeUint {
		return &SUDTAllocation{inner: slice}, nil
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SUDTAllocation", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SUDTAllocation", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SUDTAllocation", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}
	itemCount := uint32(offsetFirst)/HeaderSizeUint - 1

	offsets := make([]uint32, itemCount)

	for i := 0; i < int(itemCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}

	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			errMsg := strings.Join([]string{"OffsetsNotMatch", "SUDTAllocation"}, " ")
			return nil, errors.New(errMsg)
		}
	}

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 {
			start := offsets[i-1]
			end := offsets[i]
			_, err := SUDTBalancesFromSlice(slice[start:end], compatible)

			if err != nil {
				return nil, err
			}
		}
	}

	return &SUDTAllocation{inner: slice}, nil
}

func (s *SUDTAllocation) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SUDTAllocation) ItemCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SUDTAllocation) Len() uint {
	return s.ItemCount()
}
func (s *SUDTAllocation) IsEmpty() bool {
	return s.Len() == 0
}

// if *SUDTBalances is nil, index is out of bounds
func (s *SUDTAllocation) Get(index uint) *SUDTBalances {
	var b *SUDTBalances
	if index < s.Len() {
		start_index := uint(HeaderSizeUint) * (1 + index)
		start := unpackNumber(s.inner[start_index:])

		if index == s.Len()-1 {
			b = SUDTBalancesFromSliceUnchecked(s.inner[start:])
		} else {
			end_index := start_index + uint(HeaderSizeUint)
			end := unpackNumber(s.inner[end_index:])
			b = SUDTBalancesFromSliceUnchecked(s.inner[start:end])
		}
	}
	return b
}

func (s *SUDTAllocation) AsBuilder() SUDTAllocationBuilder {
	size := s.ItemCount()
	t := NewSUDTAllocationBuilder()
	for i := uint(0); i < size; i++ {
		t.Push(*s.Get(i))
	}
	return *t
}

type SUDTAssetBuilder struct {
	type_script  Script
	max_capacity Uint64
}

func (s *SUDTAssetBuilder) Build() SUDTAsset {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.type_script.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.max_capacity.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.type_script.AsSlice())
	b.Write(s.max_capacity.AsSlice())
	return SUDTAsset{inner: b.Bytes()}
}

func (s *SUDTAssetBuilder) TypeScript(v Script) *SUDTAssetBuilder {
	s.type_script = v
	return s
}

func (s *SUDTAssetBuilder) MaxCapacity(v Uint64) *SUDTAssetBuilder {
	s.max_capacity = v
	return s
}

func NewSUDTAssetBuilder() *SUDTAssetBuilder {
	return &SUDTAssetBuilder{type_script: ScriptDefault(), max_capacity: Uint64Default()}
}

type SUDTAsset struct {
	inner []byte
}

func SUDTAssetFromSliceUnchecked(slice []byte) *SUDTAsset {
	return &SUDTAsset{inner: slice}
}
func (s *SUDTAsset) AsSlice() []byte {
	return s.inner
}

func SUDTAssetDefault() SUDTAsset {
	return *SUDTAssetFromSliceUnchecked([]byte{73, 0, 0, 0, 12, 0, 0, 0, 65, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func SUDTAssetFromSlice(slice []byte, compatible bool) (*SUDTAsset, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SUDTAsset", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SUDTAsset", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SUDTAsset", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SUDTAsset", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SUDTAsset", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ScriptFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &SUDTAsset{inner: slice}, nil
}

func (s *SUDTAsset) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SUDTAsset) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SUDTAsset) Len() uint {
	return s.FieldCount()
}
func (s *SUDTAsset) IsEmpty() bool {
	return s.Len() == 0
}
func (s *SUDTAsset) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *SUDTAsset) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *SUDTAsset) TypeScript() *Script {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ScriptFromSliceUnchecked(s.inner[start:end])
}

func (s *SUDTAsset) MaxCapacity() *Uint64 {
	var ret *Uint64
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = Uint64FromSliceUnchecked(s.inner[start:end])
	} else {
		ret = Uint64FromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *SUDTAsset) AsBuilder() SUDTAssetBuilder {
	ret := NewSUDTAssetBuilder().TypeScript(*s.TypeScript()).MaxCapacity(*s.MaxCapacity())
	return *ret
}

type SUDTBalancesBuilder struct {
	asset        SUDTAsset
	distribution SUDTDistribution
}

func (s *SUDTBalancesBuilder) Build() SUDTBalances {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.asset.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.distribution.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.asset.AsSlice())
	b.Write(s.distribution.AsSlice())
	return SUDTBalances{inner: b.Bytes()}
}

func (s *SUDTBalancesBuilder) Asset(v SUDTAsset) *SUDTBalancesBuilder {
	s.asset = v
	return s
}

func (s *SUDTBalancesBuilder) Distribution(v SUDTDistribution) *SUDTBalancesBuilder {
	s.distribution = v
	return s
}

func NewSUDTBalancesBuilder() *SUDTBalancesBuilder {
	return &SUDTBalancesBuilder{asset: SUDTAssetDefault(), distribution: SUDTDistributionDefault()}
}

type SUDTBalances struct {
	inner []byte
}

func SUDTBalancesFromSliceUnchecked(slice []byte) *SUDTBalances {
	return &SUDTBalances{inner: slice}
}
func (s *SUDTBalances) AsSlice() []byte {
	return s.inner
}

func SUDTBalancesDefault() SUDTBalances {
	return *SUDTBalancesFromSliceUnchecked([]byte{117, 0, 0, 0, 12, 0, 0, 0, 85, 0, 0, 0, 73, 0, 0, 0, 12, 0, 0, 0, 65, 0, 0, 0, 53, 0, 0, 0, 16, 0, 0, 0, 48, 0, 0, 0, 49, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func SUDTBalancesFromSlice(slice []byte, compatible bool) (*SUDTBalances, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SUDTBalances", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SUDTBalances", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "SUDTBalances", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "SUDTBalances", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "SUDTBalances", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = SUDTAssetFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = SUDTDistributionFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &SUDTBalances{inner: slice}, nil
}

func (s *SUDTBalances) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *SUDTBalances) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *SUDTBalances) Len() uint {
	return s.FieldCount()
}
func (s *SUDTBalances) IsEmpty() bool {
	return s.Len() == 0
}
func (s *SUDTBalances) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *SUDTBalances) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *SUDTBalances) Asset() *SUDTAsset {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return SUDTAssetFromSliceUnchecked(s.inner[start:end])
}

func (s *SUDTBalances) Distribution() *SUDTDistribution {
	var ret *SUDTDistribution
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = SUDTDistributionFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = SUDTDistributionFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *SUDTBalances) AsBuilder() SUDTBalancesBuilder {
	ret := NewSUDTBalancesBuilder().Asset(*s.Asset()).Distribution(*s.Distribution())
	return *ret
}

type BalancesBuilder struct {
	ckbytes CKByteDistribution
	sudts   SUDTAllocation
}

func (s *BalancesBuilder) Build() Balances {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.ckbytes.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sudts.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.ckbytes.AsSlice())
	b.Write(s.sudts.AsSlice())
	return Balances{inner: b.Bytes()}
}

func (s *BalancesBuilder) Ckbytes(v CKByteDistribution) *BalancesBuilder {
	s.ckbytes = v
	return s
}

func (s *BalancesBuilder) Sudts(v SUDTAllocation) *BalancesBuilder {
	s.sudts = v
	return s
}

func NewBalancesBuilder() *BalancesBuilder {
	return &BalancesBuilder{ckbytes: CKByteDistributionDefault(), sudts: SUDTAllocationDefault()}
}

type Balances struct {
	inner []byte
}

func BalancesFromSliceUnchecked(slice []byte) *Balances {
	return &Balances{inner: slice}
}
func (s *Balances) AsSlice() []byte {
	return s.inner
}

func BalancesDefault() Balances {
	return *BalancesFromSliceUnchecked([]byte{32, 0, 0, 0, 12, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0})
}

func BalancesFromSlice(slice []byte, compatible bool) (*Balances, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Balances", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Balances", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Balances", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Balances", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Balances", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = CKByteDistributionFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = SUDTAllocationFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &Balances{inner: slice}, nil
}

func (s *Balances) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Balances) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Balances) Len() uint {
	return s.FieldCount()
}
func (s *Balances) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Balances) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *Balances) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *Balances) Ckbytes() *CKByteDistribution {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return CKByteDistributionFromSliceUnchecked(s.inner[start:end])
}

func (s *Balances) Sudts() *SUDTAllocation {
	var ret *SUDTAllocation
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = SUDTAllocationFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = SUDTAllocationFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Balances) AsBuilder() BalancesBuilder {
	ret := NewBalancesBuilder().Ckbytes(*s.Ckbytes()).Sudts(*s.Sudts())
	return *ret
}

type TrueBuilder struct {
	inner [1]Byte
}

func NewTrueBuilder() *TrueBuilder {
	return &TrueBuilder{inner: [1]Byte{ByteDefault()}}
}

func (s *TrueBuilder) Build() True {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return True{inner: b.Bytes()}
}

func (s *TrueBuilder) Set(v [1]Byte) *TrueBuilder {
	s.inner = v
	return s
}

func (s *TrueBuilder) Nth0(v Byte) *TrueBuilder {
	s.inner[0] = v
	return s
}

type True struct {
	inner []byte
}

func TrueFromSliceUnchecked(slice []byte) *True {
	return &True{inner: slice}
}
func (s *True) AsSlice() []byte {
	return s.inner
}

func TrueDefault() True {
	return *TrueFromSliceUnchecked([]byte{0})
}

func TrueFromSlice(slice []byte, _compatible bool) (*True, error) {
	sliceLen := len(slice)
	if sliceLen != 1 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "True", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(1)}, " ")
		return nil, errors.New(errMsg)
	}
	return &True{inner: slice}, nil
}

func (s *True) RawData() []byte {
	return s.inner
}

func (s *True) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *True) AsBuilder() TrueBuilder {
	t := NewTrueBuilder()
	t.Nth0(*s.Nth0())
	return *t
}

type FalseBuilder struct {
	inner [1]Byte
}

func NewFalseBuilder() *FalseBuilder {
	return &FalseBuilder{inner: [1]Byte{ByteDefault()}}
}

func (s *FalseBuilder) Build() False {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return False{inner: b.Bytes()}
}

func (s *FalseBuilder) Set(v [1]Byte) *FalseBuilder {
	s.inner = v
	return s
}

func (s *FalseBuilder) Nth0(v Byte) *FalseBuilder {
	s.inner[0] = v
	return s
}

type False struct {
	inner []byte
}

func FalseFromSliceUnchecked(slice []byte) *False {
	return &False{inner: slice}
}
func (s *False) AsSlice() []byte {
	return s.inner
}

func FalseDefault() False {
	return *FalseFromSliceUnchecked([]byte{0})
}

func FalseFromSlice(slice []byte, _compatible bool) (*False, error) {
	sliceLen := len(slice)
	if sliceLen != 1 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "False", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(1)}, " ")
		return nil, errors.New(errMsg)
	}
	return &False{inner: slice}, nil
}

func (s *False) RawData() []byte {
	return s.inner
}

func (s *False) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *False) AsBuilder() FalseBuilder {
	t := NewFalseBuilder()
	t.Nth0(*s.Nth0())
	return *t
}

type BoolBuilder struct {
	inner BoolUnion
}

func NewBoolBuilder() *BoolBuilder {
	v := BoolDefault()
	return &BoolBuilder{inner: *v.ToUnion()}
}
func (s *BoolBuilder) Set(v BoolUnion) *BoolBuilder {
	s.inner = v
	return s
}
func (s *BoolBuilder) Build() Bool {
	b := new(bytes.Buffer)
	b.Write(packNumber(s.inner.itemID))
	b.Write(s.inner.AsSlice())

	return Bool{inner: b.Bytes()}
}

type Bool struct {
	inner []byte
}

func BoolFromSliceUnchecked(slice []byte) *Bool {
	return &Bool{inner: slice}
}
func (s *Bool) AsSlice() []byte {
	return s.inner
}

func BoolDefault() Bool {
	return *BoolFromSliceUnchecked([]byte{0, 0, 0, 0, 0})
}

type BoolUnion struct {
	itemID Number
	inner  []byte
}

func (s *BoolUnion) AsSlice() []byte {
	return s.inner
}
func (s *BoolUnion) ItemID() Number {
	return s.itemID
}

func BoolUnionFromTrue(v True) BoolUnion {
	return BoolUnion{itemID: 0, inner: v.AsSlice()}
}

func (s *BoolUnion) IntoTrue() *True {
	switch s.ItemID() {
	case 0:
		return TrueFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 0, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func BoolUnionFromFalse(v False) BoolUnion {
	return BoolUnion{itemID: 1, inner: v.AsSlice()}
}

func (s *BoolUnion) IntoFalse() *False {
	switch s.ItemID() {
	case 1:
		return FalseFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 1, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func (s *BoolUnion) ItemName() string {
	switch s.itemID {

	case 0:
		return "True"

	case 1:
		return "False"

	default:
		panic("invalid data: BoolUnion")
	}
}

func (s *Bool) ToUnion() *BoolUnion {
	switch s.ItemID() {

	case 0:
		return &BoolUnion{itemID: 0, inner: s.inner[HeaderSizeUint:]}

	case 1:
		return &BoolUnion{itemID: 1, inner: s.inner[HeaderSizeUint:]}

	default:
		panic("invalid data: Bool")
	}
}

func BoolFromSlice(slice []byte, compatible bool) (*Bool, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Bool", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemID := unpackNumber(slice)
	innerSlice := slice[HeaderSizeUint:]

	switch itemID {

	case 0:
		_, err := TrueFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	case 1:
		_, err := FalseFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	default:
		return nil, errors.New("UnknownItem, Bool")
	}
	return &Bool{inner: slice}, nil
}

func (s *Bool) ItemID() Number {
	return unpackNumber(s.inner)
}
func (s *Bool) AsBuilder() BoolBuilder {
	return *NewBoolBuilder().Set(*s.ToUnion())
}

type ABuilder struct {
	inner [1]Byte
}

func NewABuilder() *ABuilder {
	return &ABuilder{inner: [1]Byte{ByteDefault()}}
}

func (s *ABuilder) Build() A {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return A{inner: b.Bytes()}
}

func (s *ABuilder) Set(v [1]Byte) *ABuilder {
	s.inner = v
	return s
}

func (s *ABuilder) Nth0(v Byte) *ABuilder {
	s.inner[0] = v
	return s
}

type A struct {
	inner []byte
}

func AFromSliceUnchecked(slice []byte) *A {
	return &A{inner: slice}
}
func (s *A) AsSlice() []byte {
	return s.inner
}

func ADefault() A {
	return *AFromSliceUnchecked([]byte{0})
}

func AFromSlice(slice []byte, _compatible bool) (*A, error) {
	sliceLen := len(slice)
	if sliceLen != 1 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "A", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(1)}, " ")
		return nil, errors.New(errMsg)
	}
	return &A{inner: slice}, nil
}

func (s *A) RawData() []byte {
	return s.inner
}

func (s *A) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *A) AsBuilder() ABuilder {
	t := NewABuilder()
	t.Nth0(*s.Nth0())
	return *t
}

type BBuilder struct {
	inner [1]Byte
}

func NewBBuilder() *BBuilder {
	return &BBuilder{inner: [1]Byte{ByteDefault()}}
}

func (s *BBuilder) Build() B {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return B{inner: b.Bytes()}
}

func (s *BBuilder) Set(v [1]Byte) *BBuilder {
	s.inner = v
	return s
}

func (s *BBuilder) Nth0(v Byte) *BBuilder {
	s.inner[0] = v
	return s
}

type B struct {
	inner []byte
}

func BFromSliceUnchecked(slice []byte) *B {
	return &B{inner: slice}
}
func (s *B) AsSlice() []byte {
	return s.inner
}

func BDefault() B {
	return *BFromSliceUnchecked([]byte{0})
}

func BFromSlice(slice []byte, _compatible bool) (*B, error) {
	sliceLen := len(slice)
	if sliceLen != 1 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "B", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(1)}, " ")
		return nil, errors.New(errMsg)
	}
	return &B{inner: slice}, nil
}

func (s *B) RawData() []byte {
	return s.inner
}

func (s *B) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *B) AsBuilder() BBuilder {
	t := NewBBuilder()
	t.Nth0(*s.Nth0())
	return *t
}

type AppBuilder struct {
	isNone bool
	inner  Bytes
}

func NewAppBuilder() *AppBuilder {
	return &AppBuilder{isNone: true, inner: BytesDefault()}
}
func (s *AppBuilder) Set(v Bytes) *AppBuilder {
	s.isNone = false
	s.inner = v
	return s
}
func (s *AppBuilder) Build() App {
	var ret App
	if s.isNone {
		ret = App{inner: []byte{}}
	} else {
		ret = App{inner: s.inner.AsSlice()}
	}
	return ret
}

type App struct {
	inner []byte
}

func AppFromSliceUnchecked(slice []byte) *App {
	return &App{inner: slice}
}
func (s *App) AsSlice() []byte {
	return s.inner
}

func AppDefault() App {
	return *AppFromSliceUnchecked([]byte{})
}

func AppFromSlice(slice []byte, compatible bool) (*App, error) {
	if len(slice) == 0 {
		return &App{inner: slice}, nil
	}

	_, err := BytesFromSlice(slice, compatible)
	if err != nil {
		return nil, err
	}
	return &App{inner: slice}, nil
}

func (s *App) IntoBytes() (*Bytes, error) {
	if s.IsNone() {
		return nil, errors.New("No data")
	}
	return BytesFromSliceUnchecked(s.AsSlice()), nil
}
func (s *App) IsSome() bool {
	return len(s.inner) != 0
}
func (s *App) IsNone() bool {
	return len(s.inner) == 0
}
func (s *App) AsBuilder() AppBuilder {
	var ret = NewAppBuilder()
	if s.IsSome() {
		ret.Set(*BytesFromSliceUnchecked(s.AsSlice()))
	}
	return *ret
}

type ParticipantBuilder struct {
	payment_script_hash  Byte32
	payment_min_capacity Uint64
	unlock_script_hash   Byte32
	pub_key              SEC1EncodedPubKey
}

func (s *ParticipantBuilder) Build() Participant {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (4 + 1)
	offsets := make([]uint32, 0, 4)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.payment_script_hash.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.payment_min_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.unlock_script_hash.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pub_key.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.payment_script_hash.AsSlice())
	b.Write(s.payment_min_capacity.AsSlice())
	b.Write(s.unlock_script_hash.AsSlice())
	b.Write(s.pub_key.AsSlice())
	return Participant{inner: b.Bytes()}
}

func (s *ParticipantBuilder) PaymentScriptHash(v Byte32) *ParticipantBuilder {
	s.payment_script_hash = v
	return s
}

func (s *ParticipantBuilder) PaymentMinCapacity(v Uint64) *ParticipantBuilder {
	s.payment_min_capacity = v
	return s
}

func (s *ParticipantBuilder) UnlockScriptHash(v Byte32) *ParticipantBuilder {
	s.unlock_script_hash = v
	return s
}

func (s *ParticipantBuilder) PubKey(v SEC1EncodedPubKey) *ParticipantBuilder {
	s.pub_key = v
	return s
}

func NewParticipantBuilder() *ParticipantBuilder {
	return &ParticipantBuilder{payment_script_hash: Byte32Default(), payment_min_capacity: Uint64Default(), unlock_script_hash: Byte32Default(), pub_key: SEC1EncodedPubKeyDefault()}
}

type Participant struct {
	inner []byte
}

func ParticipantFromSliceUnchecked(slice []byte) *Participant {
	return &Participant{inner: slice}
}
func (s *Participant) AsSlice() []byte {
	return s.inner
}

func ParticipantDefault() Participant {
	return *ParticipantFromSliceUnchecked([]byte{125, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ParticipantFromSlice(slice []byte, compatible bool) (*Participant, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Participant", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Participant", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Participant", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Participant", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Participant", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 4 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 4 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Byte32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = SEC1EncodedPubKeyFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	return &Participant{inner: slice}, nil
}

func (s *Participant) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Participant) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Participant) Len() uint {
	return s.FieldCount()
}
func (s *Participant) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Participant) CountExtraFields() uint {
	return s.FieldCount() - 4
}

func (s *Participant) HasExtraFields() bool {
	return 4 != s.FieldCount()
}

func (s *Participant) PaymentScriptHash() *Byte32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Byte32FromSliceUnchecked(s.inner[start:end])
}

func (s *Participant) PaymentMinCapacity() *Uint64 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *Participant) UnlockScriptHash() *Byte32 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Byte32FromSliceUnchecked(s.inner[start:end])
}

func (s *Participant) PubKey() *SEC1EncodedPubKey {
	var ret *SEC1EncodedPubKey
	start := unpackNumber(s.inner[16:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[20:])
		ret = SEC1EncodedPubKeyFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = SEC1EncodedPubKeyFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Participant) AsBuilder() ParticipantBuilder {
	ret := NewParticipantBuilder().PaymentScriptHash(*s.PaymentScriptHash()).PaymentMinCapacity(*s.PaymentMinCapacity()).UnlockScriptHash(*s.UnlockScriptHash()).PubKey(*s.PubKey())
	return *ret
}

type ChannelParametersBuilder struct {
	party_a            Participant
	party_b            Participant
	nonce              Byte32
	challenge_duration Uint64
	app                App
	is_ledger_channel  Bool
	is_virtual_channel Bool
}

func (s *ChannelParametersBuilder) Build() ChannelParameters {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.party_a.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.party_b.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.nonce.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.challenge_duration.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.app.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.is_ledger_channel.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.is_virtual_channel.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.party_a.AsSlice())
	b.Write(s.party_b.AsSlice())
	b.Write(s.nonce.AsSlice())
	b.Write(s.challenge_duration.AsSlice())
	b.Write(s.app.AsSlice())
	b.Write(s.is_ledger_channel.AsSlice())
	b.Write(s.is_virtual_channel.AsSlice())
	return ChannelParameters{inner: b.Bytes()}
}

func (s *ChannelParametersBuilder) PartyA(v Participant) *ChannelParametersBuilder {
	s.party_a = v
	return s
}

func (s *ChannelParametersBuilder) PartyB(v Participant) *ChannelParametersBuilder {
	s.party_b = v
	return s
}

func (s *ChannelParametersBuilder) Nonce(v Byte32) *ChannelParametersBuilder {
	s.nonce = v
	return s
}

func (s *ChannelParametersBuilder) ChallengeDuration(v Uint64) *ChannelParametersBuilder {
	s.challenge_duration = v
	return s
}

func (s *ChannelParametersBuilder) App(v App) *ChannelParametersBuilder {
	s.app = v
	return s
}

func (s *ChannelParametersBuilder) IsLedgerChannel(v Bool) *ChannelParametersBuilder {
	s.is_ledger_channel = v
	return s
}

func (s *ChannelParametersBuilder) IsVirtualChannel(v Bool) *ChannelParametersBuilder {
	s.is_virtual_channel = v
	return s
}

func NewChannelParametersBuilder() *ChannelParametersBuilder {
	return &ChannelParametersBuilder{party_a: ParticipantDefault(), party_b: ParticipantDefault(), nonce: Byte32Default(), challenge_duration: Uint64Default(), app: AppDefault(), is_ledger_channel: BoolDefault(), is_virtual_channel: BoolDefault()}
}

type ChannelParameters struct {
	inner []byte
}

func ChannelParametersFromSliceUnchecked(slice []byte) *ChannelParameters {
	return &ChannelParameters{inner: slice}
}
func (s *ChannelParameters) AsSlice() []byte {
	return s.inner
}

func ChannelParametersDefault() ChannelParameters {
	return *ChannelParametersFromSliceUnchecked([]byte{76, 1, 0, 0, 32, 0, 0, 0, 157, 0, 0, 0, 26, 1, 0, 0, 58, 1, 0, 0, 66, 1, 0, 0, 66, 1, 0, 0, 71, 1, 0, 0, 125, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ChannelParametersFromSlice(slice []byte, compatible bool) (*ChannelParameters, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChannelParameters", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChannelParameters", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChannelParameters", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ChannelParameters", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChannelParameters", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ParticipantFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ParticipantFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = AppFromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BoolFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BoolFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &ChannelParameters{inner: slice}, nil
}

func (s *ChannelParameters) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ChannelParameters) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ChannelParameters) Len() uint {
	return s.FieldCount()
}
func (s *ChannelParameters) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ChannelParameters) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *ChannelParameters) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *ChannelParameters) PartyA() *Participant {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ParticipantFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelParameters) PartyB() *Participant {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return ParticipantFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelParameters) Nonce() *Byte32 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Byte32FromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelParameters) ChallengeDuration() *Uint64 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelParameters) App() *App {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return AppFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelParameters) IsLedgerChannel() *Bool {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return BoolFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelParameters) IsVirtualChannel() *Bool {
	var ret *Bool
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = BoolFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BoolFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ChannelParameters) AsBuilder() ChannelParametersBuilder {
	ret := NewChannelParametersBuilder().PartyA(*s.PartyA()).PartyB(*s.PartyB()).Nonce(*s.Nonce()).ChallengeDuration(*s.ChallengeDuration()).App(*s.App()).IsLedgerChannel(*s.IsLedgerChannel()).IsVirtualChannel(*s.IsVirtualChannel())
	return *ret
}

type ChannelConstantsBuilder struct {
	params            ChannelParameters
	pfls_code_hash    Byte32
	pfls_hash_type    Byte
	pfls_min_capacity Uint64
	pcls_code_hash    Byte32
	pcls_hash_type    Byte
	thread_token      ChannelToken
}

func (s *ChannelConstantsBuilder) Build() ChannelConstants {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (7 + 1)
	offsets := make([]uint32, 0, 7)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.params.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pfls_code_hash.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pfls_hash_type.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pfls_min_capacity.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pcls_code_hash.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.pcls_hash_type.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.thread_token.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.params.AsSlice())
	b.Write(s.pfls_code_hash.AsSlice())
	b.Write(s.pfls_hash_type.AsSlice())
	b.Write(s.pfls_min_capacity.AsSlice())
	b.Write(s.pcls_code_hash.AsSlice())
	b.Write(s.pcls_hash_type.AsSlice())
	b.Write(s.thread_token.AsSlice())
	return ChannelConstants{inner: b.Bytes()}
}

func (s *ChannelConstantsBuilder) Params(v ChannelParameters) *ChannelConstantsBuilder {
	s.params = v
	return s
}

func (s *ChannelConstantsBuilder) PflsCodeHash(v Byte32) *ChannelConstantsBuilder {
	s.pfls_code_hash = v
	return s
}

func (s *ChannelConstantsBuilder) PflsHashType(v Byte) *ChannelConstantsBuilder {
	s.pfls_hash_type = v
	return s
}

func (s *ChannelConstantsBuilder) PflsMinCapacity(v Uint64) *ChannelConstantsBuilder {
	s.pfls_min_capacity = v
	return s
}

func (s *ChannelConstantsBuilder) PclsCodeHash(v Byte32) *ChannelConstantsBuilder {
	s.pcls_code_hash = v
	return s
}

func (s *ChannelConstantsBuilder) PclsHashType(v Byte) *ChannelConstantsBuilder {
	s.pcls_hash_type = v
	return s
}

func (s *ChannelConstantsBuilder) ThreadToken(v ChannelToken) *ChannelConstantsBuilder {
	s.thread_token = v
	return s
}

func NewChannelConstantsBuilder() *ChannelConstantsBuilder {
	return &ChannelConstantsBuilder{params: ChannelParametersDefault(), pfls_code_hash: Byte32Default(), pfls_hash_type: ByteDefault(), pfls_min_capacity: Uint64Default(), pcls_code_hash: Byte32Default(), pcls_hash_type: ByteDefault(), thread_token: ChannelTokenDefault()}
}

type ChannelConstants struct {
	inner []byte
}

func ChannelConstantsFromSliceUnchecked(slice []byte) *ChannelConstants {
	return &ChannelConstants{inner: slice}
}
func (s *ChannelConstants) AsSlice() []byte {
	return s.inner
}

func ChannelConstantsDefault() ChannelConstants {
	return *ChannelConstantsFromSliceUnchecked([]byte{218, 1, 0, 0, 32, 0, 0, 0, 108, 1, 0, 0, 140, 1, 0, 0, 141, 1, 0, 0, 149, 1, 0, 0, 181, 1, 0, 0, 182, 1, 0, 0, 76, 1, 0, 0, 32, 0, 0, 0, 157, 0, 0, 0, 26, 1, 0, 0, 58, 1, 0, 0, 66, 1, 0, 0, 66, 1, 0, 0, 71, 1, 0, 0, 125, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 125, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 60, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ChannelConstantsFromSlice(slice []byte, compatible bool) (*ChannelConstants, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChannelConstants", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChannelConstants", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChannelConstants", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ChannelConstants", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChannelConstants", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 7 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 7 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ChannelParametersFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32FromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ByteFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Byte32FromSlice(slice[offsets[4]:offsets[5]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ByteFromSlice(slice[offsets[5]:offsets[6]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = ChannelTokenFromSlice(slice[offsets[6]:offsets[7]], compatible)
	if err != nil {
		return nil, err
	}

	return &ChannelConstants{inner: slice}, nil
}

func (s *ChannelConstants) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ChannelConstants) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ChannelConstants) Len() uint {
	return s.FieldCount()
}
func (s *ChannelConstants) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ChannelConstants) CountExtraFields() uint {
	return s.FieldCount() - 7
}

func (s *ChannelConstants) HasExtraFields() bool {
	return 7 != s.FieldCount()
}

func (s *ChannelConstants) Params() *ChannelParameters {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ChannelParametersFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelConstants) PflsCodeHash() *Byte32 {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return Byte32FromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelConstants) PflsHashType() *Byte {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return ByteFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelConstants) PflsMinCapacity() *Uint64 {
	start := unpackNumber(s.inner[16:])
	end := unpackNumber(s.inner[20:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelConstants) PclsCodeHash() *Byte32 {
	start := unpackNumber(s.inner[20:])
	end := unpackNumber(s.inner[24:])
	return Byte32FromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelConstants) PclsHashType() *Byte {
	start := unpackNumber(s.inner[24:])
	end := unpackNumber(s.inner[28:])
	return ByteFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelConstants) ThreadToken() *ChannelToken {
	var ret *ChannelToken
	start := unpackNumber(s.inner[28:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[32:])
		ret = ChannelTokenFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = ChannelTokenFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ChannelConstants) AsBuilder() ChannelConstantsBuilder {
	ret := NewChannelConstantsBuilder().Params(*s.Params()).PflsCodeHash(*s.PflsCodeHash()).PflsHashType(*s.PflsHashType()).PflsMinCapacity(*s.PflsMinCapacity()).PclsCodeHash(*s.PclsCodeHash()).PclsHashType(*s.PclsHashType()).ThreadToken(*s.ThreadToken())
	return *ret
}

type FundBuilder struct {
	inner [1]Byte
}

func NewFundBuilder() *FundBuilder {
	return &FundBuilder{inner: [1]Byte{ByteDefault()}}
}

func (s *FundBuilder) Build() Fund {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Fund{inner: b.Bytes()}
}

func (s *FundBuilder) Set(v [1]Byte) *FundBuilder {
	s.inner = v
	return s
}

func (s *FundBuilder) Nth0(v Byte) *FundBuilder {
	s.inner[0] = v
	return s
}

type Fund struct {
	inner []byte
}

func FundFromSliceUnchecked(slice []byte) *Fund {
	return &Fund{inner: slice}
}
func (s *Fund) AsSlice() []byte {
	return s.inner
}

func FundDefault() Fund {
	return *FundFromSliceUnchecked([]byte{0})
}

func FundFromSlice(slice []byte, _compatible bool) (*Fund, error) {
	sliceLen := len(slice)
	if sliceLen != 1 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Fund", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(1)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Fund{inner: slice}, nil
}

func (s *Fund) RawData() []byte {
	return s.inner
}

func (s *Fund) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Fund) AsBuilder() FundBuilder {
	t := NewFundBuilder()
	t.Nth0(*s.Nth0())
	return *t
}

type AbortBuilder struct {
	inner [1]Byte
}

func NewAbortBuilder() *AbortBuilder {
	return &AbortBuilder{inner: [1]Byte{ByteDefault()}}
}

func (s *AbortBuilder) Build() Abort {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return Abort{inner: b.Bytes()}
}

func (s *AbortBuilder) Set(v [1]Byte) *AbortBuilder {
	s.inner = v
	return s
}

func (s *AbortBuilder) Nth0(v Byte) *AbortBuilder {
	s.inner[0] = v
	return s
}

type Abort struct {
	inner []byte
}

func AbortFromSliceUnchecked(slice []byte) *Abort {
	return &Abort{inner: slice}
}
func (s *Abort) AsSlice() []byte {
	return s.inner
}

func AbortDefault() Abort {
	return *AbortFromSliceUnchecked([]byte{0})
}

func AbortFromSlice(slice []byte, _compatible bool) (*Abort, error) {
	sliceLen := len(slice)
	if sliceLen != 1 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Abort", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(1)}, " ")
		return nil, errors.New(errMsg)
	}
	return &Abort{inner: slice}, nil
}

func (s *Abort) RawData() []byte {
	return s.inner
}

func (s *Abort) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *Abort) AsBuilder() AbortBuilder {
	t := NewAbortBuilder()
	t.Nth0(*s.Nth0())
	return *t
}

type DisputeBuilder struct {
	sig_a Bytes
	sig_b Bytes
}

func (s *DisputeBuilder) Build() Dispute {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (2 + 1)
	offsets := make([]uint32, 0, 2)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sig_a.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sig_b.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.sig_a.AsSlice())
	b.Write(s.sig_b.AsSlice())
	return Dispute{inner: b.Bytes()}
}

func (s *DisputeBuilder) SigA(v Bytes) *DisputeBuilder {
	s.sig_a = v
	return s
}

func (s *DisputeBuilder) SigB(v Bytes) *DisputeBuilder {
	s.sig_b = v
	return s
}

func NewDisputeBuilder() *DisputeBuilder {
	return &DisputeBuilder{sig_a: BytesDefault(), sig_b: BytesDefault()}
}

type Dispute struct {
	inner []byte
}

func DisputeFromSliceUnchecked(slice []byte) *Dispute {
	return &Dispute{inner: slice}
}
func (s *Dispute) AsSlice() []byte {
	return s.inner
}

func DisputeDefault() Dispute {
	return *DisputeFromSliceUnchecked([]byte{20, 0, 0, 0, 12, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func DisputeFromSlice(slice []byte, compatible bool) (*Dispute, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Dispute", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Dispute", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Dispute", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Dispute", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Dispute", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 2 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 2 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = BytesFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	return &Dispute{inner: slice}, nil
}

func (s *Dispute) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Dispute) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Dispute) Len() uint {
	return s.FieldCount()
}
func (s *Dispute) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Dispute) CountExtraFields() uint {
	return s.FieldCount() - 2
}

func (s *Dispute) HasExtraFields() bool {
	return 2 != s.FieldCount()
}

func (s *Dispute) SigA() *Bytes {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Dispute) SigB() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[8:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[12:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Dispute) AsBuilder() DisputeBuilder {
	ret := NewDisputeBuilder().SigA(*s.SigA()).SigB(*s.SigB())
	return *ret
}

type CloseBuilder struct {
	state ChannelState
	sig_a Bytes
	sig_b Bytes
}

func (s *CloseBuilder) Build() Close {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.state.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sig_a.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.sig_b.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.state.AsSlice())
	b.Write(s.sig_a.AsSlice())
	b.Write(s.sig_b.AsSlice())
	return Close{inner: b.Bytes()}
}

func (s *CloseBuilder) State(v ChannelState) *CloseBuilder {
	s.state = v
	return s
}

func (s *CloseBuilder) SigA(v Bytes) *CloseBuilder {
	s.sig_a = v
	return s
}

func (s *CloseBuilder) SigB(v Bytes) *CloseBuilder {
	s.sig_b = v
	return s
}

func NewCloseBuilder() *CloseBuilder {
	return &CloseBuilder{state: ChannelStateDefault(), sig_a: BytesDefault(), sig_b: BytesDefault()}
}

type Close struct {
	inner []byte
}

func CloseFromSliceUnchecked(slice []byte) *Close {
	return &Close{inner: slice}
}
func (s *Close) AsSlice() []byte {
	return s.inner
}

func CloseDefault() Close {
	return *CloseFromSliceUnchecked([]byte{121, 0, 0, 0, 16, 0, 0, 0, 113, 0, 0, 0, 117, 0, 0, 0, 97, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 12, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func CloseFromSlice(slice []byte, compatible bool) (*Close, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Close", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Close", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "Close", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "Close", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "Close", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ChannelStateFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BytesFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &Close{inner: slice}, nil
}

func (s *Close) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *Close) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *Close) Len() uint {
	return s.FieldCount()
}
func (s *Close) IsEmpty() bool {
	return s.Len() == 0
}
func (s *Close) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *Close) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *Close) State() *ChannelState {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ChannelStateFromSliceUnchecked(s.inner[start:end])
}

func (s *Close) SigA() *Bytes {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BytesFromSliceUnchecked(s.inner[start:end])
}

func (s *Close) SigB() *Bytes {
	var ret *Bytes
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = BytesFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BytesFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *Close) AsBuilder() CloseBuilder {
	ret := NewCloseBuilder().State(*s.State()).SigA(*s.SigA()).SigB(*s.SigB())
	return *ret
}

type ForceCloseBuilder struct {
	inner [1]Byte
}

func NewForceCloseBuilder() *ForceCloseBuilder {
	return &ForceCloseBuilder{inner: [1]Byte{ByteDefault()}}
}

func (s *ForceCloseBuilder) Build() ForceClose {
	b := new(bytes.Buffer)
	len := len(s.inner)
	for i := 0; i < len; i++ {
		b.Write(s.inner[i].AsSlice())
	}
	return ForceClose{inner: b.Bytes()}
}

func (s *ForceCloseBuilder) Set(v [1]Byte) *ForceCloseBuilder {
	s.inner = v
	return s
}

func (s *ForceCloseBuilder) Nth0(v Byte) *ForceCloseBuilder {
	s.inner[0] = v
	return s
}

type ForceClose struct {
	inner []byte
}

func ForceCloseFromSliceUnchecked(slice []byte) *ForceClose {
	return &ForceClose{inner: slice}
}
func (s *ForceClose) AsSlice() []byte {
	return s.inner
}

func ForceCloseDefault() ForceClose {
	return *ForceCloseFromSliceUnchecked([]byte{0})
}

func ForceCloseFromSlice(slice []byte, _compatible bool) (*ForceClose, error) {
	sliceLen := len(slice)
	if sliceLen != 1 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ForceClose", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(1)}, " ")
		return nil, errors.New(errMsg)
	}
	return &ForceClose{inner: slice}, nil
}

func (s *ForceClose) RawData() []byte {
	return s.inner
}

func (s *ForceClose) Nth0() *Byte {
	ret := ByteFromSliceUnchecked(s.inner[0:1])
	return ret
}

func (s *ForceClose) AsBuilder() ForceCloseBuilder {
	t := NewForceCloseBuilder()
	t.Nth0(*s.Nth0())
	return *t
}

type ChannelWitnessBuilder struct {
	inner ChannelWitnessUnion
}

func NewChannelWitnessBuilder() *ChannelWitnessBuilder {
	v := ChannelWitnessDefault()
	return &ChannelWitnessBuilder{inner: *v.ToUnion()}
}
func (s *ChannelWitnessBuilder) Set(v ChannelWitnessUnion) *ChannelWitnessBuilder {
	s.inner = v
	return s
}
func (s *ChannelWitnessBuilder) Build() ChannelWitness {
	b := new(bytes.Buffer)
	b.Write(packNumber(s.inner.itemID))
	b.Write(s.inner.AsSlice())

	return ChannelWitness{inner: b.Bytes()}
}

type ChannelWitness struct {
	inner []byte
}

func ChannelWitnessFromSliceUnchecked(slice []byte) *ChannelWitness {
	return &ChannelWitness{inner: slice}
}
func (s *ChannelWitness) AsSlice() []byte {
	return s.inner
}

func ChannelWitnessDefault() ChannelWitness {
	return *ChannelWitnessFromSliceUnchecked([]byte{0, 0, 0, 0, 0})
}

type ChannelWitnessUnion struct {
	itemID Number
	inner  []byte
}

func (s *ChannelWitnessUnion) AsSlice() []byte {
	return s.inner
}
func (s *ChannelWitnessUnion) ItemID() Number {
	return s.itemID
}

func ChannelWitnessUnionFromFund(v Fund) ChannelWitnessUnion {
	return ChannelWitnessUnion{itemID: 0, inner: v.AsSlice()}
}

func (s *ChannelWitnessUnion) IntoFund() *Fund {
	switch s.ItemID() {
	case 0:
		return FundFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 0, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func ChannelWitnessUnionFromAbort(v Abort) ChannelWitnessUnion {
	return ChannelWitnessUnion{itemID: 1, inner: v.AsSlice()}
}

func (s *ChannelWitnessUnion) IntoAbort() *Abort {
	switch s.ItemID() {
	case 1:
		return AbortFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 1, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func ChannelWitnessUnionFromDispute(v Dispute) ChannelWitnessUnion {
	return ChannelWitnessUnion{itemID: 2, inner: v.AsSlice()}
}

func (s *ChannelWitnessUnion) IntoDispute() *Dispute {
	switch s.ItemID() {
	case 2:
		return DisputeFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 2, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func ChannelWitnessUnionFromClose(v Close) ChannelWitnessUnion {
	return ChannelWitnessUnion{itemID: 3, inner: v.AsSlice()}
}

func (s *ChannelWitnessUnion) IntoClose() *Close {
	switch s.ItemID() {
	case 3:
		return CloseFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 3, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func ChannelWitnessUnionFromForceClose(v ForceClose) ChannelWitnessUnion {
	return ChannelWitnessUnion{itemID: 4, inner: v.AsSlice()}
}

func (s *ChannelWitnessUnion) IntoForceClose() *ForceClose {
	switch s.ItemID() {
	case 4:
		return ForceCloseFromSliceUnchecked(s.AsSlice())
	default:
		errMsg := strings.Join([]string{"invalid item_id: expect 4, found", strconv.Itoa(int(s.ItemID()))}, " ")
		panic(errMsg)
	}
}

func (s *ChannelWitnessUnion) ItemName() string {
	switch s.itemID {

	case 0:
		return "Fund"

	case 1:
		return "Abort"

	case 2:
		return "Dispute"

	case 3:
		return "Close"

	case 4:
		return "ForceClose"

	default:
		panic("invalid data: ChannelWitnessUnion")
	}
}

func (s *ChannelWitness) ToUnion() *ChannelWitnessUnion {
	switch s.ItemID() {

	case 0:
		return &ChannelWitnessUnion{itemID: 0, inner: s.inner[HeaderSizeUint:]}

	case 1:
		return &ChannelWitnessUnion{itemID: 1, inner: s.inner[HeaderSizeUint:]}

	case 2:
		return &ChannelWitnessUnion{itemID: 2, inner: s.inner[HeaderSizeUint:]}

	case 3:
		return &ChannelWitnessUnion{itemID: 3, inner: s.inner[HeaderSizeUint:]}

	case 4:
		return &ChannelWitnessUnion{itemID: 4, inner: s.inner[HeaderSizeUint:]}

	default:
		panic("invalid data: ChannelWitness")
	}
}

func ChannelWitnessFromSlice(slice []byte, compatible bool) (*ChannelWitness, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChannelWitness", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}
	itemID := unpackNumber(slice)
	innerSlice := slice[HeaderSizeUint:]

	switch itemID {

	case 0:
		_, err := FundFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	case 1:
		_, err := AbortFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	case 2:
		_, err := DisputeFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	case 3:
		_, err := CloseFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	case 4:
		_, err := ForceCloseFromSlice(innerSlice, compatible)
		if err != nil {
			return nil, err
		}

	default:
		return nil, errors.New("UnknownItem, ChannelWitness")
	}
	return &ChannelWitness{inner: slice}, nil
}

func (s *ChannelWitness) ItemID() Number {
	return unpackNumber(s.inner)
}
func (s *ChannelWitness) AsBuilder() ChannelWitnessBuilder {
	return *NewChannelWitnessBuilder().Set(*s.ToUnion())
}

type ChannelStateBuilder struct {
	channel_id Byte32
	balances   Balances
	version    Uint64
	is_final   Bool
}

func (s *ChannelStateBuilder) Build() ChannelState {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (4 + 1)
	offsets := make([]uint32, 0, 4)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.channel_id.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.balances.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.version.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.is_final.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.channel_id.AsSlice())
	b.Write(s.balances.AsSlice())
	b.Write(s.version.AsSlice())
	b.Write(s.is_final.AsSlice())
	return ChannelState{inner: b.Bytes()}
}

func (s *ChannelStateBuilder) ChannelId(v Byte32) *ChannelStateBuilder {
	s.channel_id = v
	return s
}

func (s *ChannelStateBuilder) Balances(v Balances) *ChannelStateBuilder {
	s.balances = v
	return s
}

func (s *ChannelStateBuilder) Version(v Uint64) *ChannelStateBuilder {
	s.version = v
	return s
}

func (s *ChannelStateBuilder) IsFinal(v Bool) *ChannelStateBuilder {
	s.is_final = v
	return s
}

func NewChannelStateBuilder() *ChannelStateBuilder {
	return &ChannelStateBuilder{channel_id: Byte32Default(), balances: BalancesDefault(), version: Uint64Default(), is_final: BoolDefault()}
}

type ChannelState struct {
	inner []byte
}

func ChannelStateFromSliceUnchecked(slice []byte) *ChannelState {
	return &ChannelState{inner: slice}
}
func (s *ChannelState) AsSlice() []byte {
	return s.inner
}

func ChannelStateDefault() ChannelState {
	return *ChannelStateFromSliceUnchecked([]byte{97, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 12, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ChannelStateFromSlice(slice []byte, compatible bool) (*ChannelState, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChannelState", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChannelState", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChannelState", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ChannelState", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChannelState", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 4 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 4 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = Byte32FromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BalancesFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = Uint64FromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BoolFromSlice(slice[offsets[3]:offsets[4]], compatible)
	if err != nil {
		return nil, err
	}

	return &ChannelState{inner: slice}, nil
}

func (s *ChannelState) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ChannelState) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ChannelState) Len() uint {
	return s.FieldCount()
}
func (s *ChannelState) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ChannelState) CountExtraFields() uint {
	return s.FieldCount() - 4
}

func (s *ChannelState) HasExtraFields() bool {
	return 4 != s.FieldCount()
}

func (s *ChannelState) ChannelId() *Byte32 {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return Byte32FromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelState) Balances() *Balances {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BalancesFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelState) Version() *Uint64 {
	start := unpackNumber(s.inner[12:])
	end := unpackNumber(s.inner[16:])
	return Uint64FromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelState) IsFinal() *Bool {
	var ret *Bool
	start := unpackNumber(s.inner[16:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[20:])
		ret = BoolFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BoolFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ChannelState) AsBuilder() ChannelStateBuilder {
	ret := NewChannelStateBuilder().ChannelId(*s.ChannelId()).Balances(*s.Balances()).Version(*s.Version()).IsFinal(*s.IsFinal())
	return *ret
}

type ChannelStatusBuilder struct {
	state    ChannelState
	funded   Bool
	disputed Bool
}

func (s *ChannelStatusBuilder) Build() ChannelStatus {
	b := new(bytes.Buffer)

	totalSize := HeaderSizeUint * (3 + 1)
	offsets := make([]uint32, 0, 3)

	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.state.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.funded.AsSlice()))
	offsets = append(offsets, totalSize)
	totalSize += uint32(len(s.disputed.AsSlice()))

	b.Write(packNumber(Number(totalSize)))

	for i := 0; i < len(offsets); i++ {
		b.Write(packNumber(Number(offsets[i])))
	}

	b.Write(s.state.AsSlice())
	b.Write(s.funded.AsSlice())
	b.Write(s.disputed.AsSlice())
	return ChannelStatus{inner: b.Bytes()}
}

func (s *ChannelStatusBuilder) State(v ChannelState) *ChannelStatusBuilder {
	s.state = v
	return s
}

func (s *ChannelStatusBuilder) Funded(v Bool) *ChannelStatusBuilder {
	s.funded = v
	return s
}

func (s *ChannelStatusBuilder) Disputed(v Bool) *ChannelStatusBuilder {
	s.disputed = v
	return s
}

func NewChannelStatusBuilder() *ChannelStatusBuilder {
	return &ChannelStatusBuilder{state: ChannelStateDefault(), funded: BoolDefault(), disputed: BoolDefault()}
}

type ChannelStatus struct {
	inner []byte
}

func ChannelStatusFromSliceUnchecked(slice []byte) *ChannelStatus {
	return &ChannelStatus{inner: slice}
}
func (s *ChannelStatus) AsSlice() []byte {
	return s.inner
}

func ChannelStatusDefault() ChannelStatus {
	return *ChannelStatusFromSliceUnchecked([]byte{123, 0, 0, 0, 16, 0, 0, 0, 113, 0, 0, 0, 118, 0, 0, 0, 97, 0, 0, 0, 20, 0, 0, 0, 52, 0, 0, 0, 84, 0, 0, 0, 92, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32, 0, 0, 0, 12, 0, 0, 0, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ChannelStatusFromSlice(slice []byte, compatible bool) (*ChannelStatus, error) {
	sliceLen := len(slice)
	if uint32(sliceLen) < HeaderSizeUint {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChannelStatus", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint))}, " ")
		return nil, errors.New(errMsg)
	}

	totalSize := unpackNumber(slice)
	if Number(sliceLen) != totalSize {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChannelStatus", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(int(totalSize))}, " ")
		return nil, errors.New(errMsg)
	}

	if uint32(sliceLen) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChannelStatus", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	offsetFirst := unpackNumber(slice[HeaderSizeUint:])
	if uint32(offsetFirst)%HeaderSizeUint != 0 || uint32(offsetFirst) < HeaderSizeUint*2 {
		errMsg := strings.Join([]string{"OffsetsNotMatch", "ChannelStatus", strconv.Itoa(int(offsetFirst % 4)), "!= 0", strconv.Itoa(int(offsetFirst)), "<", strconv.Itoa(int(HeaderSizeUint * 2))}, " ")
		return nil, errors.New(errMsg)
	}

	if sliceLen < int(offsetFirst) {
		errMsg := strings.Join([]string{"HeaderIsBroken", "ChannelStatus", strconv.Itoa(int(sliceLen)), "<", strconv.Itoa(int(offsetFirst))}, " ")
		return nil, errors.New(errMsg)
	}

	fieldCount := uint32(offsetFirst)/HeaderSizeUint - 1
	if fieldCount < 3 {
		return nil, errors.New("FieldCountNotMatch")
	} else if !compatible && fieldCount > 3 {
		return nil, errors.New("FieldCountNotMatch")
	}

	offsets := make([]uint32, fieldCount)

	for i := 0; i < int(fieldCount); i++ {
		offsets[i] = uint32(unpackNumber(slice[HeaderSizeUint:][int(HeaderSizeUint)*i:]))
	}
	offsets = append(offsets, uint32(totalSize))

	for i := 0; i < len(offsets); i++ {
		if i&1 != 0 && offsets[i-1] > offsets[i] {
			return nil, errors.New("OffsetsNotMatch")
		}
	}

	var err error

	_, err = ChannelStateFromSlice(slice[offsets[0]:offsets[1]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BoolFromSlice(slice[offsets[1]:offsets[2]], compatible)
	if err != nil {
		return nil, err
	}

	_, err = BoolFromSlice(slice[offsets[2]:offsets[3]], compatible)
	if err != nil {
		return nil, err
	}

	return &ChannelStatus{inner: slice}, nil
}

func (s *ChannelStatus) TotalSize() uint {
	return uint(unpackNumber(s.inner))
}
func (s *ChannelStatus) FieldCount() uint {
	var number uint = 0
	if uint32(s.TotalSize()) == HeaderSizeUint {
		return number
	}
	number = uint(unpackNumber(s.inner[HeaderSizeUint:]))/4 - 1
	return number
}
func (s *ChannelStatus) Len() uint {
	return s.FieldCount()
}
func (s *ChannelStatus) IsEmpty() bool {
	return s.Len() == 0
}
func (s *ChannelStatus) CountExtraFields() uint {
	return s.FieldCount() - 3
}

func (s *ChannelStatus) HasExtraFields() bool {
	return 3 != s.FieldCount()
}

func (s *ChannelStatus) State() *ChannelState {
	start := unpackNumber(s.inner[4:])
	end := unpackNumber(s.inner[8:])
	return ChannelStateFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelStatus) Funded() *Bool {
	start := unpackNumber(s.inner[8:])
	end := unpackNumber(s.inner[12:])
	return BoolFromSliceUnchecked(s.inner[start:end])
}

func (s *ChannelStatus) Disputed() *Bool {
	var ret *Bool
	start := unpackNumber(s.inner[12:])
	if s.HasExtraFields() {
		end := unpackNumber(s.inner[16:])
		ret = BoolFromSliceUnchecked(s.inner[start:end])
	} else {
		ret = BoolFromSliceUnchecked(s.inner[start:])
	}
	return ret
}

func (s *ChannelStatus) AsBuilder() ChannelStatusBuilder {
	ret := NewChannelStatusBuilder().State(*s.State()).Funded(*s.Funded()).Disputed(*s.Disputed())
	return *ret
}

type ChannelTokenBuilder struct {
	out_point OutPoint
}

func (s *ChannelTokenBuilder) Build() ChannelToken {
	b := new(bytes.Buffer)
	b.Write(s.out_point.AsSlice())
	return ChannelToken{inner: b.Bytes()}
}

func (s *ChannelTokenBuilder) OutPoint(v OutPoint) *ChannelTokenBuilder {
	s.out_point = v
	return s
}

func NewChannelTokenBuilder() *ChannelTokenBuilder {
	return &ChannelTokenBuilder{out_point: OutPointDefault()}
}

type ChannelToken struct {
	inner []byte
}

func ChannelTokenFromSliceUnchecked(slice []byte) *ChannelToken {
	return &ChannelToken{inner: slice}
}
func (s *ChannelToken) AsSlice() []byte {
	return s.inner
}

func ChannelTokenDefault() ChannelToken {
	return *ChannelTokenFromSliceUnchecked([]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
}

func ChannelTokenFromSlice(slice []byte, _compatible bool) (*ChannelToken, error) {
	sliceLen := len(slice)
	if sliceLen != 36 {
		errMsg := strings.Join([]string{"TotalSizeNotMatch", "ChannelToken", strconv.Itoa(int(sliceLen)), "!=", strconv.Itoa(36)}, " ")
		return nil, errors.New(errMsg)
	}
	return &ChannelToken{inner: slice}, nil
}

func (s *ChannelToken) OutPoint() *OutPoint {
	ret := OutPointFromSliceUnchecked(s.inner[0:36])
	return ret
}

func (s *ChannelToken) AsBuilder() ChannelTokenBuilder {
	ret := NewChannelTokenBuilder().OutPoint(*s.OutPoint())
	return *ret
}
